# How to use AFL+K-Scheduler on fuzzuf

K-Scheduler is an algorithm to prioritize seeds in the queue of AFL like fuzzers. K-Scheduler calculates Katz centrality of each vertex of the control flow graph. Katz centrality is one of the graph centrality defitnition, that gives higher score on the vertex which often need to pass to reach one vertex to other vertices.
K-Scheduler calculates centrality of each vertex of the control flow graph, and generates importance of covered vertices which faces uncovered vertices according to centrality of uncovered vertices. 
On control flow graph, as a vertex is a basic block, this process finds the basic block that there are many uncovered basic blocks reachable only after the basic block is executed.
It generates importance of each seeds by summing the importance of vertices on the path, then select the seed which has the highest importance in the unselected seeds.
Since the seed reaches high centrality basic block takes high importance, this results fuzzer to select the seed that reaches one step prior of uncovered basic block in higher priority.
This increase the chance to generate input that reaches to  unocvered basic block by mutation.
Centrality caluculations takes long time on complex graph, thus the calculation is done in separated script asynchronousely.
Fuzzer and the script pass there state to each other sometime but not every cycles.

K-Scheduler can be combined with most AFL like algorithms. "afl\_kscheduler" combines K-Scheduler with traditional AFL. Thus the usage is almost same as plain afl except the centrality calculation script need to be executed beside.

The centrality of whole control flow graph is calculated prior to start fuzzer by gen\_graph.py. 
gen\_dyn\_weight.py reads coverage generated by the fuzzer, drop vertices those are already covered, and recalculate centrality. Latter script runs beside the fuzzer. gen\_graph.py and gen\_dyn\_wiehgt.py located at tools tools/kscheduler/ are almost same as scripts included in original K-Scheduler implementation but extract control flow graph embedded in the executable instead to generate control flow graph using LLVM IR. This is expected to use with fuzzuf-cc's feature that embed control flow graph as an ELF section.

## Usage

```
$ fuzzuf afl_kscheduler [options]
```

Basic usage is shown below.

Generate centrality. This produces border\_edge, child\_node, graph\_data\_pack, katz\_cent and parent\_node in the \<ROOT\_DIR\>.
graph\_data\_pack is a pickled python dictionary that contains whole control flow graph.
katz\_cent is a calculated centrality of each vertices.
Since the scripts and fuzzer read/write files in the current directory, it is highly recommended to create empty \<ROOT\_DIR\> and move into the directory prior to do anything.
\<PUT\> is the target executable binary. The binary must contain control flow graph as a section. Such binary can be generated using fuzzuf-cc.

```
$ cd <ROOT_DIR>
$ gen_graph.py <PUT>
```

Run fuzzer. This produces cur\_coverage and signal.
cur\_coverage contains already covered vertex IDs.
The fuzzer set 1 on signal, that indicates gen\_dyn\_weight.py should generate new dyn\_katz\_cent. gen\_dyn\_weight.py overwrites the file by 0, that indicates fuzzer should load generated dyn\_katz\_cent.
\<INITIAL\_SEED\_DIR\> is a directory that contains initial seeds. \<OUTPUT\_DIR\> is a directory to output fuzzing state. \<ARGS\_FOR\_PUT\> are arguments for the PUT. Special argument value "@@" indicates the name of input file generated by fuzzer should be placed at there.
-e forkserver --forksrv true requests to use fork server mode. This requires the PUT is built with a fuzzf-cc feature --features=forkserver. Since the original implementation of K-Scheduler uses forkserver, this is needed for fair performance comparison.
-s requests to assume basic block IDs are assigned sequentially. This requires the PUT is built with a fuzzuf-cc option --bb-id-assigner-id-generation-strategy=SEQUENTIAL. -s enables some optimizations those are valid only if the basic block IDs are sequential. As original K-Scheduler does this optimization, it is needed to match fuzzuf's behavior to original.
-d disables deterministic stage of AFL. Since deterministic stage causes performance regression, the sample included in original K-Scheduler implementation disable the stage. Therefore this option is needed to match fuzzuf's behavior to the sample.

```
$ cd <OUTPUT_DIR>
$ fuzzuf afl_kscheduler -i <INITIAL_SEED_DIR> -o <OUTPUT_DIR> -e forkserver --forksrv true -s -d <PUT> <ARGS_FOR_PUT>
```

Run gen\_dyn\_weight.py on another terminal. This produces dyn\_katz\_cent.
This script reads graph\_data\_pack and cur\_coverage and generate control flow graph excluding already covered blocks, then calculate centrality according the graph. The calculated centrality is written to dyn\_katz\_cent, and signal is set to 0 to notify fuzzer to read dyn\_katz\_cent.
Both fuzzer and the script read/write to current directory, it is important to run both at same directory.

```
$ cd <OUTPUT_DIR>
$ gen_dyn_weight.py
```

The PUT binary must contain control flow graph generated by fuzzuf-cc. Since K-Scheduler requires all basic blocks in the PUT to have unique ID, all translation units must be linked at once. To generate such binary, fuzzuf-cc must be called with following arguments.

```
$ fuzzuf-cc -flto --bitmap-load-point=FullLinkTimeOptimizationLast --cfg-exporter-load-point=FullLinkTimeOptimizationLast --bitmap-instrumentation-method=NODE --features=bb-id-assigner,bitmap-feedback,cfg-exporter
```

-flto --bitmap-load-point=FullLinkTimeOptimizationLast --cfg-exporter-load-point=FullLinkTimeOptimizationLast requests compiler to generate basic block ID and control flow graph in link time. This is mandatory due to K-Scheduler requires unique IDs for each blocks.
--bitmap-instrumentation-method=NODE disable using edge ID. K-Scheduler calculates centrality for each basic blocks, thus coverage bitmap must indicate which basic blocks are covered. Since fuzzuf-cc uses edge ID as default, explicitly disabling edge ID is needed.

The option above generates executable binary with control flow graph yet no forkserver support nor sequential ID optimization support. To support forkserver, add forkserver to --features.

```
$ fuzzuf-cc -flto --bitmap-load-point=FullLinkTimeOptimizationLast --cfg-exporter-load-point=FullLinkTimeOptimizationLast --bitmap-instrumentation-method=NODE --features=bb-id-assigner,bitmap-feedback,cfg-exporter,forkserver
```

To generate basic block IDs in sequential, add --bb-id-assigner-id-generation-strategy=SEQUENTIAL.

```
$ fuzzuf-cc -flto --bitmap-load-point=FullLinkTimeOptimizationLast --cfg-exporter-load-point=FullLinkTimeOptimizationLast --bitmap-instrumentation-method=NODE --bb-id-assigner-id-generation-strategy=SEQUENTIAL --features=bb-id-assigner,bitmap-feedback,cfg-exporter,forkserver
```

## Note for Ubuntu users

gen\_graph.py and gen\_dyn\_graph.py requires Python module called networkit. Since Ubuntu doesn't provide a package for networkit, the module need to be installed by pip or some sort of unofficial method. Furthermore, networkx, scipy, numpy and ipdb provided on Ubuntu 20.04 or prior is too old, thus have issue to combine with latest version installed by pip as dependency of networkit. So it is highly recommended to install those modules into virtual env using pip.

## Options

All global options and AFL specific options described in [afl/algorithms](../afl/algorithm_en.md) are available.

In addition following options are available

### --det

Skip deterministic steps.

### --sequential

Assume basic block ids are sequential.
In this mode, coverage bitmap beyond the highest basic block IDs are ignored.
If the PUT has small number of basic blocks, this reduces cost to search or count over coverage bitmap dramatically.

## Implementation

Centrality calculation is done in python scripts located at tools/kscheduler. Those scripts are the modified version of one included in original K-Scheduler implementation.
utils/kscheduler contains parsers to read files generated by scripts.
Most of other changes including seed importance calculation are located in include/algorithms/afl/ and those are activated only if the fuzzing algorithm set EnableKScheduler true.
Directories name afl\_kscheduler contains only EnableKScheduler and some boilerplate to expose the algorithm to CLI.
This design make easy to add K-Scheduler support on other afl like algorithms.

## Debug feature

Modify EnableVerboseDebugLog in include/fuzzuf/algorithms/afl\_kscheduler/option.hpp to true and set runlevel to Debug, then all node entrance and leave events are logged with elapsed time.
This make easy to detect nodes those are unexpectedly skipped or consuming much time.

Modify EnableKSchedulerSortByEnergy in include/fuzzuf/algorithms/afl\_kscheduler/option.hpp to true, sorting seeds by importance is skipped, thus the seeds are selected in order, irrelevantly to the calculated vertex centrality and seed importance.
This make easy to measure the effect of selecting high importance seed.

